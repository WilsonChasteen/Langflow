Skip to content <https://docs.pydantic.dev/2.10/errors/
validation_errors/#arguments_type>

What's new â€” we've launched Pydantic Logfire <https://pydantic.dev/
articles/logfire-announcement> ðŸ”¥ to help you monitor and understand
your Postgres queries. <https://logfire.pydantic.dev/docs/integrations/
asyncpg/>

logo <https://docs.pydantic.dev/2.10/>

Pydantic
2.10

  * dev <https://docs.pydantic.dev/dev/>
  * 2.10 <https://docs.pydantic.dev/2.10/>
  * 2.9 <https://docs.pydantic.dev/2.9/>
  * 2.8 <https://docs.pydantic.dev/2.8/>
  * 2.7 <https://docs.pydantic.dev/2.7/>
  * 2.6 <https://docs.pydantic.dev/2.6/>
  * 2.5 <https://docs.pydantic.dev/2.5/>
  * 2.4 <https://docs.pydantic.dev/2.4/>
  * 2.3 <https://docs.pydantic.dev/2.3/>
  * 2.2 <https://docs.pydantic.dev/2.2/>
  * 2.1 <https://docs.pydantic.dev/2.1/>
  * 2.0 <https://docs.pydantic.dev/2.0/>
  * 1.10 <https://docs.pydantic.dev/1.10/>

Validation Errors

Type to start searching

pydantic/pydantic

  * v2.10.6
  * 22.7k
  * 2k

<https://github.com/pydantic/pydantic>

  * Get Started <https://docs.pydantic.dev/2.10/>
  * Concepts <https://docs.pydantic.dev/2.10/concepts/models/>
  * API Documentation <https://docs.pydantic.dev/2.10/api/base_model/>
  * Internals <https://docs.pydantic.dev/2.10/internals/architecture/>
  * Examples <https://docs.pydantic.dev/2.10/examples/files/>
  * Error Messages <https://docs.pydantic.dev/2.10/errors/errors/>
  * Integrations <https://docs.pydantic.dev/2.10/integrations/logfire/>
  * Blog <https://blog.pydantic.dev/>
  * Pydantic People <https://docs.pydantic.dev/2.10/pydantic_people/>

logo <https://docs.pydantic.dev/2.10/> Pydantic

pydantic/pydantic

  * v2.10.6
  * 22.7k
  * 2k

<https://github.com/pydantic/pydantic>

  *
    Get Started

    Get Started
      o Welcome to Pydantic <https://docs.pydantic.dev/2.10/>
      o Why use Pydantic <https://docs.pydantic.dev/2.10/why/>
      o Help with Pydantic <https://docs.pydantic.dev/2.10/
        help_with_pydantic/>
      o Installation <https://docs.pydantic.dev/2.10/install/>
      o Migration Guide <https://docs.pydantic.dev/2.10/migration/>
      o Version Policy <https://docs.pydantic.dev/2.10/version-policy/>
      o Contributing <https://docs.pydantic.dev/2.10/contributing/>
      o Changelog <https://docs.pydantic.dev/2.10/changelog/>

  *
    Concepts

    Concepts
      o Models <https://docs.pydantic.dev/2.10/concepts/models/>
      o Fields <https://docs.pydantic.dev/2.10/concepts/fields/>
      o JSON Schema <https://docs.pydantic.dev/2.10/concepts/json_schema/>
      o JSON <https://docs.pydantic.dev/2.10/concepts/json/>
      o Types <https://docs.pydantic.dev/2.10/concepts/types/>
      o Unions <https://docs.pydantic.dev/2.10/concepts/unions/>
      o Alias <https://docs.pydantic.dev/2.10/concepts/alias/>
      o Configuration <https://docs.pydantic.dev/2.10/concepts/config/>
      o Serialization <https://docs.pydantic.dev/2.10/concepts/
        serialization/>
      o Validators <https://docs.pydantic.dev/2.10/concepts/validators/>
      o Dataclasses <https://docs.pydantic.dev/2.10/concepts/dataclasses/>
      o Forward Annotations <https://docs.pydantic.dev/2.10/concepts/
        forward_annotations/>
      o Strict Mode <https://docs.pydantic.dev/2.10/concepts/strict_mode/>
      o Type Adapter <https://docs.pydantic.dev/2.10/concepts/
        type_adapter/>
      o Validation Decorator <https://docs.pydantic.dev/2.10/concepts/
        validation_decorator/>
      o Conversion Table <https://docs.pydantic.dev/2.10/concepts/
        conversion_table/>
      o Settings Management <https://docs.pydantic.dev/2.10/concepts/
        pydantic_settings/>
      o Performance <https://docs.pydantic.dev/2.10/concepts/performance/>
      o Experimental <https://docs.pydantic.dev/2.10/concepts/
        experimental/>

  *
    API Documentation

    API Documentation
      o
        Pydantic

        Pydantic
          + BaseModel <https://docs.pydantic.dev/2.10/api/base_model/>
          + RootModel <https://docs.pydantic.dev/2.10/api/root_model/>
          + Pydantic Dataclasses <https://docs.pydantic.dev/2.10/api/
            dataclasses/>
          + TypeAdapter <https://docs.pydantic.dev/2.10/api/type_adapter/>
          + Validate Call <https://docs.pydantic.dev/2.10/api/
            validate_call/>
          + Fields <https://docs.pydantic.dev/2.10/api/fields/>
          + Aliases <https://docs.pydantic.dev/2.10/api/aliases/>
          + Configuration <https://docs.pydantic.dev/2.10/api/config/>
          + JSON Schema <https://docs.pydantic.dev/2.10/api/json_schema/>
          + Errors <https://docs.pydantic.dev/2.10/api/errors/>
          + Functional Validators <https://docs.pydantic.dev/2.10/api/
            functional_validators/>
          + Functional Serializers <https://docs.pydantic.dev/2.10/api/
            functional_serializers/>
          + Standard Library Types <https://docs.pydantic.dev/2.10/api/
            standard_library_types/>
          + Pydantic Types <https://docs.pydantic.dev/2.10/api/types/>
          + Network Types <https://docs.pydantic.dev/2.10/api/networks/>
          + Version Information <https://docs.pydantic.dev/2.10/api/
            version/>
          + Annotated Handlers <https://docs.pydantic.dev/2.10/api/
            annotated_handlers/>
          + Experimental <https://docs.pydantic.dev/2.10/api/experimental/>

      o
        Pydantic Core

        Pydantic Core
          + pydantic_core <https://docs.pydantic.dev/2.10/api/
            pydantic_core/>
          + pydantic_core.core_schema <https://docs.pydantic.dev/2.10/
            api/pydantic_core_schema/>

      o Pydantic Settings <https://docs.pydantic.dev/2.10/api/
        pydantic_settings/>
      o
        Pydantic Extra Types

        Pydantic Extra Types
          + Color <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_color/>
          + Country <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_country/>
          + Payment <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_payment/>
          + Phone Numbers <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_phone_numbers/>
          + Routing Numbers <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_routing_numbers/>
          + Coordinate <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_coordinate/>
          + Mac Address <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_mac_address/>
          + ISBN <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_isbn/>
          + Pendulum <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_pendulum_dt/>
          + Currency <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_currency_code/>
          + Language <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_language_code/>
          + Script Code <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_script_code/>
          + Semantic Version <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_semantic_version/>
          + Timezone Name <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_timezone_name/>
          + ULID <https://docs.pydantic.dev/2.10/api/
            pydantic_extra_types_ulid/>

  *
    Internals

    Internals
      o Architecture <https://docs.pydantic.dev/2.10/internals/
        architecture/>
      o Resolving Annotations <https://docs.pydantic.dev/2.10/internals/
        resolving_annotations/>

  *
    Examples

    Examples
      o Validating File Data <https://docs.pydantic.dev/2.10/examples/
        files/>
      o Web and API Requests <https://docs.pydantic.dev/2.10/examples/
        requests/>
      o Queues <https://docs.pydantic.dev/2.10/examples/queues/>
      o Databases <https://docs.pydantic.dev/2.10/examples/orms/>
      o Custom Validators <https://docs.pydantic.dev/2.10/examples/
        custom_validators/>

  *
    Error Messages

    Error Messages
      o Error Handling <https://docs.pydantic.dev/2.10/errors/errors/>
      o Validation Errors Validation Errors <https://
        docs.pydantic.dev/2.10/errors/validation_errors/>
        Page contents

          + arguments_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#arguments_type>
          + assertion_error <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#assertion_error>
          + bool_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#bool_parsing>
          + bool_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#bool_type>
          + bytes_invalid_encoding <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#bytes_invalid_encoding>
          + bytes_too_long <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#bytes_too_long>
          + bytes_too_short <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#bytes_too_short>
          + bytes_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#bytes_type>
          + callable_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#callable_type>
          + complex_str_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#complex_str_parsing>
          + complex_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#complex_type>
          + dataclass_exact_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#dataclass_exact_type>
          + dataclass_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#dataclass_type>
          + date_from_datetime_inexact <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#date_from_datetime_inexact>
          + date_from_datetime_parsing <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#date_from_datetime_parsing>
          + date_future <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#date_future>
          + date_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#date_parsing>
          + date_past <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#date_past>
          + date_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#date_type>
          + datetime_from_date_parsing <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#datetime_from_date_parsing>
          + datetime_future <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#datetime_future>
          + datetime_object_invalid <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#datetime_object_invalid>
          + datetime_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#datetime_parsing>
          + datetime_past <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#datetime_past>
          + datetime_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#datetime_type>
          + decimal_max_digits <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#decimal_max_digits>
          + decimal_max_places <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#decimal_max_places>
          + decimal_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#decimal_parsing>
          + decimal_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#decimal_type>
          + decimal_whole_digits <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#decimal_whole_digits>
          + dict_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#dict_type>
          + enum <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#enum>
          + extra_forbidden <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#extra_forbidden>
          + finite_number <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#finite_number>
          + float_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#float_parsing>
          + float_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#float_type>
          + frozen_field <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#frozen_field>
          + frozen_instance <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#frozen_instance>
          + frozen_set_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#frozen_set_type>
          + get_attribute_error <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#get_attribute_error>
          + greater_than <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#greater_than>
          + greater_than_equal <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#greater_than_equal>
          + int_from_float <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#int_from_float>
          + int_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#int_parsing>
          + int_parsing_size <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#int_parsing_size>
          + int_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#int_type>
          + invalid_key <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#invalid_key>
          + is_instance_of <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#is_instance_of>
          + is_subclass_of <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#is_subclass_of>
          + iterable_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#iterable_type>
          + iteration_error <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#iteration_error>
          + json_invalid <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#json_invalid>
          + json_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#json_type>
          + less_than <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#less_than>
          + less_than_equal <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#less_than_equal>
          + list_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#list_type>
          + literal_error <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#literal_error>
          + mapping_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#mapping_type>
          + missing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#missing>
          + missing_argument <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#missing_argument>
          + missing_keyword_only_argument <https://
            docs.pydantic.dev/2.10/errors/validation_errors/
            #missing_keyword_only_argument>
          + missing_positional_only_argument <https://
            docs.pydantic.dev/2.10/errors/validation_errors/
            #missing_positional_only_argument>
          + model_attributes_type <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#model_attributes_type>
          + model_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#model_type>
          + multiple_argument_values <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#multiple_argument_values>
          + multiple_of <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#multiple_of>
          + needs_python_object <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#needs_python_object>
          + no_such_attribute <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#no_such_attribute>
          + none_required <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#none_required>
          + recursion_loop <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#recursion_loop>
          + set_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#set_type>
          + string_pattern_mismatch <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#string_pattern_mismatch>
          + string_sub_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#string_sub_type>
          + string_too_long <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#string_too_long>
          + string_too_short <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#string_too_short>
          + string_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#string_type>
          + string_unicode <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#string_unicode>
          + time_delta_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#time_delta_parsing>
          + time_delta_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#time_delta_type>
          + time_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#time_parsing>
          + time_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#time_type>
          + timezone_aware <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#timezone_aware>
          + timezone_naive <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#timezone_naive>
          + too_long <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#too_long>
          + too_short <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#too_short>
          + tuple_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#tuple_type>
          + unexpected_keyword_argument <https://docs.pydantic.dev/2.10/
            errors/validation_errors/#unexpected_keyword_argument>
          + unexpected_positional_argument <https://
            docs.pydantic.dev/2.10/errors/validation_errors/
            #unexpected_positional_argument>
          + union_tag_invalid <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#union_tag_invalid>
          + union_tag_not_found <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#union_tag_not_found>
          + url_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#url_parsing>
          + url_scheme <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#url_scheme>
          + url_syntax_violation <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#url_syntax_violation>
          + url_too_long <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#url_too_long>
          + url_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#url_type>
          + uuid_parsing <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#uuid_parsing>
          + uuid_type <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#uuid_type>
          + uuid_version <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#uuid_version>
          + value_error <https://docs.pydantic.dev/2.10/errors/
            validation_errors/#value_error>
      o Usage Errors <https://docs.pydantic.dev/2.10/errors/usage_errors/>

  *
    Integrations

    Integrations
      o Pydantic Logfire <https://docs.pydantic.dev/2.10/integrations/
        logfire/>
      o
        Dev Tools

        Dev Tools
          + Mypy <https://docs.pydantic.dev/2.10/integrations/mypy/>
          + PyCharm <https://docs.pydantic.dev/2.10/integrations/pycharm/>
          + Hypothesis <https://docs.pydantic.dev/2.10/integrations/
            hypothesis/>
          + Visual Studio Code <https://docs.pydantic.dev/2.10/
            integrations/visual_studio_code/>
          + datamodel-code-generator <https://docs.pydantic.dev/2.10/
            integrations/datamodel_code_generator/>
          + devtools <https://docs.pydantic.dev/2.10/integrations/
            devtools/>
          + Rich <https://docs.pydantic.dev/2.10/integrations/rich/>
          + Linting <https://docs.pydantic.dev/2.10/integrations/linting/>

      o
        Production Tools

        Production Tools
          + AWS Lambda <https://docs.pydantic.dev/2.10/integrations/
            aws_lambda/>

  * Blog <https://blog.pydantic.dev/>
  * Pydantic People <https://docs.pydantic.dev/2.10/pydantic_people/>

Page contents

  * arguments_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#arguments_type>
  * assertion_error <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#assertion_error>
  * bool_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bool_parsing>
  * bool_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #bool_type>
  * bytes_invalid_encoding <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bytes_invalid_encoding>
  * bytes_too_long <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bytes_too_long>
  * bytes_too_short <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bytes_too_short>
  * bytes_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #bytes_type>
  * callable_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#callable_type>
  * complex_str_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#complex_str_parsing>
  * complex_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#complex_type>
  * dataclass_exact_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#dataclass_exact_type>
  * dataclass_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#dataclass_type>
  * date_from_datetime_inexact <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_from_datetime_inexact>
  * date_from_datetime_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_from_datetime_parsing>
  * date_future <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_future>
  * date_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_parsing>
  * date_past <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #date_past>
  * date_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #date_type>
  * datetime_from_date_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_from_date_parsing>
  * datetime_future <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_future>
  * datetime_object_invalid <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_object_invalid>
  * datetime_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_parsing>
  * datetime_past <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_past>
  * datetime_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_type>
  * decimal_max_digits <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_max_digits>
  * decimal_max_places <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_max_places>
  * decimal_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_parsing>
  * decimal_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_type>
  * decimal_whole_digits <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_whole_digits>
  * dict_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #dict_type>
  * enum <https://docs.pydantic.dev/2.10/errors/validation_errors/#enum>
  * extra_forbidden <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#extra_forbidden>
  * finite_number <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#finite_number>
  * float_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#float_parsing>
  * float_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #float_type>
  * frozen_field <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#frozen_field>
  * frozen_instance <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#frozen_instance>
  * frozen_set_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#frozen_set_type>
  * get_attribute_error <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#get_attribute_error>
  * greater_than <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#greater_than>
  * greater_than_equal <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#greater_than_equal>
  * int_from_float <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#int_from_float>
  * int_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#int_parsing>
  * int_parsing_size <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#int_parsing_size>
  * int_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #int_type>
  * invalid_key <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#invalid_key>
  * is_instance_of <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#is_instance_of>
  * is_subclass_of <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#is_subclass_of>
  * iterable_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#iterable_type>
  * iteration_error <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#iteration_error>
  * json_invalid <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#json_invalid>
  * json_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #json_type>
  * less_than <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #less_than>
  * less_than_equal <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#less_than_equal>
  * list_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #list_type>
  * literal_error <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#literal_error>
  * mapping_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#mapping_type>
  * missing <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #missing>
  * missing_argument <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#missing_argument>
  * missing_keyword_only_argument <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#missing_keyword_only_argument>
  * missing_positional_only_argument <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#missing_positional_only_argument>
  * model_attributes_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#model_attributes_type>
  * model_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #model_type>
  * multiple_argument_values <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#multiple_argument_values>
  * multiple_of <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#multiple_of>
  * needs_python_object <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#needs_python_object>
  * no_such_attribute <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#no_such_attribute>
  * none_required <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#none_required>
  * recursion_loop <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#recursion_loop>
  * set_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #set_type>
  * string_pattern_mismatch <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_pattern_mismatch>
  * string_sub_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_sub_type>
  * string_too_long <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_too_long>
  * string_too_short <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_too_short>
  * string_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_type>
  * string_unicode <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_unicode>
  * time_delta_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#time_delta_parsing>
  * time_delta_type <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#time_delta_type>
  * time_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#time_parsing>
  * time_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #time_type>
  * timezone_aware <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#timezone_aware>
  * timezone_naive <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#timezone_naive>
  * too_long <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #too_long>
  * too_short <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #too_short>
  * tuple_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #tuple_type>
  * unexpected_keyword_argument <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#unexpected_keyword_argument>
  * unexpected_positional_argument <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#unexpected_positional_argument>
  * union_tag_invalid <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#union_tag_invalid>
  * union_tag_not_found <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#union_tag_not_found>
  * url_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_parsing>
  * url_scheme <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #url_scheme>
  * url_syntax_violation <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_syntax_violation>
  * url_too_long <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_too_long>
  * url_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #url_type>
  * uuid_parsing <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#uuid_parsing>
  * uuid_type <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #uuid_type>
  * uuid_version <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#uuid_version>
  * value_error <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#value_error>


  Validation Errors

Pydantic attempts to provide useful validation errors. Below are details
on common validation errors users may encounter when working with
pydantic, together with some suggestions on how to fix them.


    |arguments_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#arguments_type>

This error is raised when an object that would be passed as arguments to
a function during validation is not a |tuple|, |list|, or |dict|.
Because |NamedTuple| uses function calls in its implementation, that is
one way to produce this error:

|from typing import NamedTuple

from pydantic import BaseModel, ValidationError


class MyNamedTuple(NamedTuple):
    x: int


class MyModel(BaseModel):
    field: MyNamedTuple


try:
    MyModel.model_validate({'field': 'invalid'})
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'arguments_type'

|


    |assertion_error|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#assertion_error>

This error is raised when a failing |assert| statement is encountered
during validation:

|from pydantic import BaseModel, ValidationError, field_validator


class Model(BaseModel):
    x: int

    @field_validator('x')
    @classmethod
    def force_x_positive(cls, v):
        assert v > 0
        return v


try:
    Model(x=-1)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'assertion_error'

|


    |bool_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bool_parsing>

This error is raised when the input value is a string that is not valid
for coercion to a boolean:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: bool


Model(x='true')  # OK

try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'bool_parsing'

|


    |bool_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bool_type>

This error is raised when the input value's type is not valid for a |
bool| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: bool


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'bool_type'

|


    |bytes_invalid_encoding|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bytes_invalid_encoding>

This error is raised when a |bytes| value is invalid under the
configured encoding. In the following example, |b'a'| is invalid hex
(odd number of digits).

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: bytes
    model_config = {'val_json_bytes': 'hex'}


try:
    Model(x=b'a')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'bytes_invalid_encoding'

|

This error is also raised for strict fields when the input value is not
an instance of |bool|.


    |bytes_too_long|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bytes_too_long>

This error is raised when the length of a |bytes| value is greater than
the field's |max_length| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: bytes = Field(max_length=3)


try:
    Model(x=b'test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'bytes_too_long'

|


    |bytes_too_short|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bytes_too_short>

This error is raised when the length of a |bytes| value is less than the
field's |min_length| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: bytes = Field(min_length=3)


try:
    Model(x=b't')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'bytes_too_short'

|


    |bytes_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#bytes_type>

This error is raised when the input value's type is not valid for a |
bytes| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: bytes


try:
    Model(x=123)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'bytes_type'

|

This error is also raised for strict fields when the input value is not
an instance of |bytes|.


    |callable_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#callable_type>

This error is raised when the input value is not valid as a |Callable|:

Python 3.8 and above <#__tabbed_1_1>

Python 3.10 and above <#__tabbed_1_2>

|from typing import Any, Callable

from pydantic import BaseModel, ImportString, ValidationError


class Model(BaseModel):
    x: ImportString[Callable[[Any], Any]]


Model(x='math:cos')  # OK

try:
    Model(x='os.path')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'callable_type'

|

|from typing import Any
from collections.abc import Callable

from pydantic import BaseModel, ImportString, ValidationError


class Model(BaseModel):
    x: ImportString[Callable[[Any], Any]]


Model(x='math:cos')  # OK

try:
    Model(x='os.path')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'callable_type'

|


    |complex_str_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#complex_str_parsing>

This error is raised when the input value is a string but cannot be
parsed as a complex number because it does not follow the rule <https://
docs.python.org/3/library/functions.html#complex> in Python:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    num: complex


try:
    # Complex numbers in json are expected to be valid complex strings.
    # This value `abc` is not a valid complex string.
    Model.model_validate_json('{"num": "abc"}')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'complex_str_parsing'

|


    |complex_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#complex_type>

This error is raised when the input value cannot be interpreted as a
complex number:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    num: complex


try:
    Model(num=False)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'complex_type'

|


    |dataclass_exact_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#dataclass_exact_type>

This error is raised when validating a dataclass with |strict=True| and
the input is not an instance of the dataclass:

|import pydantic.dataclasses
from pydantic import TypeAdapter, ValidationError


@pydantic.dataclasses.dataclass
class MyDataclass:
    x: str


adapter = TypeAdapter(MyDataclass)

print(adapter.validate_python(MyDataclass(x='test'), strict=True))
#> MyDataclass(x='test')
print(adapter.validate_python({'x': 'test'}))
#> MyDataclass(x='test')

try:
    adapter.validate_python({'x': 'test'}, strict=True)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'dataclass_exact_type'

|


    |dataclass_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#dataclass_type>

This error is raised when the input value is not valid for a |dataclass|
field:

|from pydantic import ValidationError, dataclasses


@dataclasses.dataclass
class Inner:
    x: int


@dataclasses.dataclass
class Outer:
    y: Inner


Outer(y=Inner(x=1))  # OK

try:
    Outer(y=1)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'dataclass_type'

|


    |date_from_datetime_inexact|Â¶ <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#date_from_datetime_inexact>

This error is raised when the input |datetime| value provided for a |
date| field has a nonzero time component. For a timestamp to parse into
a field of type |date|, the time components must all be zero:

|from datetime import date, datetime

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: date


Model(x='2023-01-01')  # OK
Model(x=datetime(2023, 1, 1))  # OK

try:
    Model(x=datetime(2023, 1, 1, 12))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'date_from_datetime_inexact'

|


    |date_from_datetime_parsing|Â¶ <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#date_from_datetime_parsing>

This error is raised when the input value is a string that cannot be
parsed for a |date| field:

|from datetime import date

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: date


try:
    Model(x='XX1494012000')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'date_from_datetime_parsing'

|


    |date_future|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_future>

This error is raised when the input value provided for a |FutureDate|
field is not in the future:

|from datetime import date

from pydantic import BaseModel, FutureDate, ValidationError


class Model(BaseModel):
    x: FutureDate


try:
    Model(x=date(2000, 1, 1))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'date_future'

|


    |date_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_parsing>

This error is raised when validating JSON where the input value is
string that cannot be parsed for a |date| field:

|import json
from datetime import date

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: date = Field(strict=True)


try:
    Model.model_validate_json(json.dumps({'x': '1'}))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'date_parsing'

|


    |date_past|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_past>

This error is raised when the value provided for a |PastDate| field is
not in the past:

|from datetime import date, timedelta

from pydantic import BaseModel, PastDate, ValidationError


class Model(BaseModel):
    x: PastDate


try:
    Model(x=date.today() + timedelta(1))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'date_past'

|


    |date_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#date_type>

This error is raised when the input value's type is not valid for a |
date| field:

|from datetime import date

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: date


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'date_type'

|

This error is also raised for strict fields when the input value is not
an instance of |date|.


    |datetime_from_date_parsing|Â¶ <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#datetime_from_date_parsing>

Note

Support for this error, along with support for parsing datetimes from |
yyyy-MM-DD| dates will be added in |v2.6.0|

This error is raised when the input value is a string that cannot be
parsed for a |datetime| field:

|from datetime import datetime

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: datetime


try:
    # there is no 13th month
    Model(x='2023-13-01')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'datetime_from_date_parsing'

|


    |datetime_future|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_future>

This error is raised when the value provided for a |FutureDatetime|
field is not in the future:

|from datetime import datetime

from pydantic import BaseModel, FutureDatetime, ValidationError


class Model(BaseModel):
    x: FutureDatetime


try:
    Model(x=datetime(2000, 1, 1))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'datetime_future'

|


    |datetime_object_invalid|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_object_invalid>

This error is raised when something about the |datetime| object is not
valid:

|from datetime import datetime, tzinfo

from pydantic import AwareDatetime, BaseModel, ValidationError


class CustomTz(tzinfo):
    # utcoffset is not implemented!

    def tzname(self, _dt):
        return 'CustomTZ'


class Model(BaseModel):
    x: AwareDatetime


try:
    Model(x=datetime(2023, 1, 1, tzinfo=CustomTz()))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'datetime_object_invalid'

|


    |datetime_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_parsing>

This error is raised when the value is a string that cannot be parsed
for a |datetime| field:

|import json
from datetime import datetime

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: datetime = Field(strict=True)


try:
    Model.model_validate_json(json.dumps({'x': 'not a datetime'}))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'datetime_parsing'

|


    |datetime_past|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_past>

This error is raised when the value provided for a |PastDatetime| field
is not in the past:

|from datetime import datetime, timedelta

from pydantic import BaseModel, PastDatetime, ValidationError


class Model(BaseModel):
    x: PastDatetime


try:
    Model(x=datetime.now() + timedelta(100))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'datetime_past'

|


    |datetime_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#datetime_type>

This error is raised when the input value's type is not valid for a |
datetime| field:

|from datetime import datetime

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: datetime


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'datetime_type'

|

This error is also raised for strict fields when the input value is not
an instance of |datetime|.


    |decimal_max_digits|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_max_digits>

This error is raised when the value provided for a |Decimal| has too
many digits:

|from decimal import Decimal

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: Decimal = Field(max_digits=3)


try:
    Model(x='42.1234')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'decimal_max_digits'

|


    |decimal_max_places|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_max_places>

This error is raised when the value provided for a |Decimal| has too
many digits after the decimal point:

|from decimal import Decimal

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: Decimal = Field(decimal_places=3)


try:
    Model(x='42.1234')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'decimal_max_places'

|


    |decimal_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_parsing>

This error is raised when the value provided for a |Decimal| could not
be parsed as a decimal number:

|from decimal import Decimal

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: Decimal = Field(decimal_places=3)


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'decimal_parsing'

|


    |decimal_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_type>

This error is raised when the value provided for a |Decimal| is of the
wrong type:

|from decimal import Decimal

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: Decimal = Field(decimal_places=3)


try:
    Model(x=[1, 2, 3])
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'decimal_type'

|

This error is also raised for strict fields when the input value is not
an instance of |Decimal|.


    |decimal_whole_digits|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#decimal_whole_digits>

This error is raised when the value provided for a |Decimal| has more
digits before the decimal point than |max_digits| - |decimal_places| (as
long as both are specified):

|from decimal import Decimal

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: Decimal = Field(max_digits=6, decimal_places=3)


try:
    Model(x='12345.6')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'decimal_whole_digits'

|

This error is also raised for strict fields when the input value is not
an instance of |Decimal|.


    |dict_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#dict_type>

This error is raised when the input value's type is not |dict| for a |
dict| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: dict


try:
    Model(x=['1', '2'])
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'dict_type'

|


    |enum|Â¶ <https://docs.pydantic.dev/2.10/errors/validation_errors/#enum>

This error is raised when the input value does not exist in an |enum|
field members:

|from enum import Enum

from pydantic import BaseModel, ValidationError


class MyEnum(str, Enum):
    option = 'option'


class Model(BaseModel):
    x: MyEnum


try:
    Model(x='other_option')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'enum'

|


    |extra_forbidden|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#extra_forbidden>

This error is raised when the input value contains extra fields, but |
model_config['extra'] == 'forbid'|:

|from pydantic import BaseModel, ConfigDict, ValidationError


class Model(BaseModel):
    x: str

    model_config = ConfigDict(extra='forbid')


try:
    Model(x='test', y='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'extra_forbidden'

|

You can read more about the |extra| configuration in the Extra
Attributes <https://docs.pydantic.dev/2.10/api/config/
#pydantic.config.ConfigDict.extra> section.


    |finite_number|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#finite_number>

This error is raised when the value is infinite, or too large to be
represented as a 64-bit floating point number during validation:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: int


try:
    Model(x=2.2250738585072011e308)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'finite_number'

|


    |float_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#float_parsing>

This error is raised when the value is a string that can't be parsed as
a |float|:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: float


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'float_parsing'

|


    |float_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#float_type>

This error is raised when the input value's type is not valid for a |
float| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: float


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'float_type'

|


    |frozen_field|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#frozen_field>

This error is raised when you attempt to assign a value to a field with
|frozen=True|, or to delete such a field:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: str = Field('test', frozen=True)


model = Model()

try:
    model.x = 'test1'
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'frozen_field'

try:
    del model.x
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'frozen_field'

|


    |frozen_instance|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#frozen_instance>

This error is raised when |model_config['frozen] == True| and you
attempt to delete or assign a new value to any of the fields:

|from pydantic import BaseModel, ConfigDict, ValidationError


class Model(BaseModel):
    x: int

    model_config = ConfigDict(frozen=True)


m = Model(x=1)

try:
    m.x = 2
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'frozen_instance'

try:
    del m.x
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'frozen_instance'

|


    |frozen_set_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#frozen_set_type>

This error is raised when the input value's type is not valid for a |
frozenset| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: frozenset


try:
    model = Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'frozen_set_type'

|


    |get_attribute_error|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#get_attribute_error>

This error is raised when |model_config['from_attributes'] == True| and
an error is raised while reading the attributes:

|from pydantic import BaseModel, ConfigDict, ValidationError


class Foobar:
    def __init__(self):
        self.x = 1

    @property
    def y(self):
        raise RuntimeError('intentional error')


class Model(BaseModel):
    x: int
    y: str

    model_config = ConfigDict(from_attributes=True)


try:
    Model.model_validate(Foobar())
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'get_attribute_error'

|


    |greater_than|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#greater_than>

This error is raised when the value is not greater than the field's |gt|
constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: int = Field(gt=10)


try:
    Model(x=10)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'greater_than'

|


    |greater_than_equal|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#greater_than_equal>

This error is raised when the value is not greater than or equal to the
field's |ge| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: int = Field(ge=10)


try:
    Model(x=9)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'greater_than_equal'

|


    |int_from_float|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#int_from_float>

This error is raised when you provide a |float| value for an |int| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: int


try:
    Model(x=0.5)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'int_from_float'

|


    |int_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#int_parsing>

This error is raised when the value can't be parsed as |int|:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: int


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'int_parsing'

|


    |int_parsing_size|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#int_parsing_size>

This error is raised when attempting to parse a python or JSON value
from a string outside the maximum range that Python |str| to |int|
parsing permits:

|import json

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: int


# from Python
assert Model(x='1' * 4_300).x == int('1' * 4_300)  # OK

too_long = '1' * 4_301
try:
    Model(x=too_long)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'int_parsing_size'

# from JSON
try:
    Model.model_validate_json(json.dumps({'x': too_long}))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'int_parsing_size'

|


    |int_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#int_type>

This error is raised when the input value's type is not valid for an |
int| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: int


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'int_type'

|


    |invalid_key|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#invalid_key>

This error is raised when attempting to validate a |dict| that has a key
that is not an instance of |str|:

|from pydantic import BaseModel, ConfigDict, ValidationError


class Model(BaseModel):
    x: int

    model_config = ConfigDict(extra='allow')


try:
    Model.model_validate({'x': 1, b'y': 2})
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'invalid_key'

|


    |is_instance_of|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#is_instance_of>

This error is raised when the input value is not an instance of the
expected type:

|from pydantic import BaseModel, ConfigDict, ValidationError


class Nested:
    x: str


class Model(BaseModel):
    y: Nested

    model_config = ConfigDict(arbitrary_types_allowed=True)


try:
    Model(y='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'is_instance_of'

|


    |is_subclass_of|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#is_subclass_of>

This error is raised when the input value is not a subclass of the
expected type:

Python 3.8 and above <#__tabbed_2_1>

Python 3.9 and above <#__tabbed_2_2>

|from typing import Type

from pydantic import BaseModel, ValidationError


class Nested:
    x: str


class Model(BaseModel):
    y: Type[Nested]


try:
    Model(y='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'is_subclass_of'

|

|from pydantic import BaseModel, ValidationError


class Nested:
    x: str


class Model(BaseModel):
    y: type[Nested]


try:
    Model(y='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'is_subclass_of'

|


    |iterable_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#iterable_type>

This error is raised when the input value is not valid as an |Iterable|:

Python 3.8 and above <#__tabbed_3_1>

Python 3.9 and above <#__tabbed_3_2>

|from typing import Iterable

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    y: Iterable


try:
    Model(y=123)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'iterable_type'

|

|from collections.abc import Iterable

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    y: Iterable


try:
    Model(y=123)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'iterable_type'

|


    |iteration_error|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#iteration_error>

This error is raised when an error occurs during iteration:

Python 3.8 and above <#__tabbed_4_1>

Python 3.9 and above <#__tabbed_4_2>

|from typing import List

from pydantic import BaseModel, ValidationError


def gen():
    yield 1
    raise RuntimeError('error')


class Model(BaseModel):
    x: List[int]


try:
    Model(x=gen())
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'iteration_error'

|

|from pydantic import BaseModel, ValidationError


def gen():
    yield 1
    raise RuntimeError('error')


class Model(BaseModel):
    x: list[int]


try:
    Model(x=gen())
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'iteration_error'

|


    |json_invalid|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#json_invalid>

This error is raised when the input value is not a valid JSON string:

|from pydantic import BaseModel, Json, ValidationError


class Model(BaseModel):
    x: Json


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'json_invalid'

|


    |json_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#json_type>

This error is raised when the input value is of a type that cannot be
parsed as JSON:

|from pydantic import BaseModel, Json, ValidationError


class Model(BaseModel):
    x: Json


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'json_type'

|


    |less_than|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#less_than>

This error is raised when the input value is not less than the field's |
lt| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: int = Field(lt=10)


try:
    Model(x=10)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'less_than'

|


    |less_than_equal|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#less_than_equal>

This error is raised when the input value is not less than or equal to
the field's |le| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: int = Field(le=10)


try:
    Model(x=11)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'less_than_equal'

|


    |list_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#list_type>

This error is raised when the input value's type is not valid for a |
list| field:

Python 3.8 and above <#__tabbed_5_1>

Python 3.9 and above <#__tabbed_5_2>

|from typing import List

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: List[int]


try:
    Model(x=1)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'list_type'

|

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: list[int]


try:
    Model(x=1)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'list_type'

|


    |literal_error|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#literal_error>

This error is raised when the input value is not one of the expected
literal values:

|from typing import Literal

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: Literal['a', 'b']


Model(x='a')  # OK

try:
    Model(x='c')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'literal_error'

|


    |mapping_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#mapping_type>

This error is raised when a problem occurs during validation due to a
failure in a call to the methods from the |Mapping| protocol, such as
|.items()|:

Python 3.8 and above <#__tabbed_6_1>

Python 3.9 and above <#__tabbed_6_2>

|from collections.abc import Mapping
from typing import Dict

from pydantic import BaseModel, ValidationError


class BadMapping(Mapping):
    def items(self):
        raise ValueError()

    def __iter__(self):
        raise ValueError()

    def __getitem__(self, key):
        raise ValueError()

    def __len__(self):
        return 1


class Model(BaseModel):
    x: Dict[str, str]


try:
    Model(x=BadMapping())
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'mapping_type'

|

|from collections.abc import Mapping

from pydantic import BaseModel, ValidationError


class BadMapping(Mapping):
    def items(self):
        raise ValueError()

    def __iter__(self):
        raise ValueError()

    def __getitem__(self, key):
        raise ValueError()

    def __len__(self):
        return 1


class Model(BaseModel):
    x: dict[str, str]


try:
    Model(x=BadMapping())
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'mapping_type'

|


    |missing|Â¶ <https://docs.pydantic.dev/2.10/errors/validation_errors/
    #missing>

This error is raised when there are required fields missing from the
input value:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: str


try:
    Model()
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'missing'

|


    |missing_argument|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#missing_argument>

This error is raised when a required positional-or-keyword argument is
not passed to a function decorated with |validate_call|:

|from pydantic import ValidationError, validate_call


@validate_call
def foo(a: int):
    return a


try:
    foo()
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'missing_argument'

|


    |missing_keyword_only_argument|Â¶ <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#missing_keyword_only_argument>

This error is raised when a required keyword-only argument is not passed
to a function decorated with |validate_call|:

|from pydantic import ValidationError, validate_call


@validate_call
def foo(*, a: int):
    return a


try:
    foo()
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'missing_keyword_only_argument'

|


    |missing_positional_only_argument|Â¶ <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#missing_positional_only_argument>

This error is raised when a required positional-only argument is not
passed to a function decorated with |validate_call|:

|from pydantic import ValidationError, validate_call


@validate_call
def foo(a: int, /):
    return a


try:
    foo()
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'missing_positional_only_argument'

|


    |model_attributes_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#model_attributes_type>

This error is raised when the input value is not a valid dictionary,
model instance, or instance that fields can be extracted from:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    a: int
    b: int


# simply validating a dict
print(Model.model_validate({'a': 1, 'b': 2}))
#> a=1 b=2


class CustomObj:
    def __init__(self, a, b):
        self.a = a
        self.b = b


# using from attributes to extract fields from an objects
print(Model.model_validate(CustomObj(3, 4), from_attributes=True))
#> a=3 b=4

try:
    Model.model_validate('not an object', from_attributes=True)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'model_attributes_type'

|


    |model_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#model_type>

This error is raised when the input to a model is not an instance of the
model or dict:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    a: int
    b: int


# simply validating a dict
m = Model.model_validate({'a': 1, 'b': 2})
print(m)
#> a=1 b=2

# validating an existing model instance
print(Model.model_validate(m))
#> a=1 b=2

try:
    Model.model_validate('not an object')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'model_type'

|


    |multiple_argument_values|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#multiple_argument_values>

This error is raised when you provide multiple values for a single
argument while calling a function decorated with |validate_call|:

|from pydantic import ValidationError, validate_call


@validate_call
def foo(a: int):
    return a


try:
    foo(1, a=2)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'multiple_argument_values'

|


    |multiple_of|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#multiple_of>

This error is raised when the input is not a multiple of a field's |
multiple_of| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: int = Field(multiple_of=5)


try:
    Model(x=1)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'multiple_of'

|


    |needs_python_object|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#needs_python_object>

This type of error is raised when validation is attempted from a format
that cannot be converted to a Python object. For example, we cannot
check |isinstance| or |issubclass| from JSON:

Python 3.8 and above <#__tabbed_7_1>

Python 3.9 and above <#__tabbed_7_2>

|import json
from typing import Type

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    bm: Type[BaseModel]


try:
    Model.model_validate_json(json.dumps({'bm': 'not a basemodel class'}))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'needs_python_object'

|

|import json

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    bm: type[BaseModel]


try:
    Model.model_validate_json(json.dumps({'bm': 'not a basemodel class'}))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'needs_python_object'

|


    |no_such_attribute|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#no_such_attribute>

This error is raised when |validate_assignment=True| in the config, and
you attempt to assign a value to an attribute that is not an existing field:

|from pydantic import ConfigDict, ValidationError, dataclasses


@dataclasses.dataclass(config=ConfigDict(validate_assignment=True))
class MyDataclass:
    x: int


m = MyDataclass(x=1)
try:
    m.y = 10
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'no_such_attribute'

|


    |none_required|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#none_required>

This error is raised when the input value is not |None| for a field that
requires |None|:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: None


try:
    Model(x=1)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'none_required'

|

Note

You may encounter this error when there is a naming collision in your
model between a field name and its type. More specifically, this error
is likely to be thrown when the default value of that field is |None|.

For example, the following would yield the |none_required| validation
error since the field |int| is set to a default value of |None| and has
the exact same name as its type, which causes problems with validation.

|from typing import Optional

from pydantic import BaseModel


class M1(BaseModel):
    int: Optional[int] = None


m = M1(int=123)  # errors

|


    |recursion_loop|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#recursion_loop>

This error is raised when a cyclic reference is detected:

|from typing import List

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: List['Model']


d = {'x': []}
d['x'].append(d)
try:
    Model(**d)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'recursion_loop'

|


    |set_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#set_type>

This error is raised when the value type is not valid for a |set| field:

Python 3.8 and above <#__tabbed_8_1>

Python 3.9 and above <#__tabbed_8_2>

|from typing import Set

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: Set[int]


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'set_type'

|

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: set[int]


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'set_type'

|


    |string_pattern_mismatch|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_pattern_mismatch>

This error is raised when the input value doesn't match the field's |
pattern| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: str = Field(pattern='test')


try:
    Model(x='1')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'string_pattern_mismatch'

|


    |string_sub_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_sub_type>

This error is raised when the value is an instance of a strict subtype
of |str| when the field is strict:

|from enum import Enum

from pydantic import BaseModel, Field, ValidationError


class MyEnum(str, Enum):
    foo = 'foo'


class Model(BaseModel):
    x: str = Field(strict=True)


try:
    Model(x=MyEnum.foo)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'string_sub_type'

|


    |string_too_long|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_too_long>

This error is raised when the input value is a string whose length is
greater than the field's |max_length| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: str = Field(max_length=3)


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'string_too_long'

|


    |string_too_short|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_too_short>

This error is raised when the input value is a string whose length is
less than the field's |min_length| constraint:

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: str = Field(min_length=3)


try:
    Model(x='t')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'string_too_short'

|


    |string_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_type>

This error is raised when the input value's type is not valid for a |
str| field:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: str


try:
    Model(x=1)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'string_type'

|

This error is also raised for strict fields when the input value is not
an instance of |str|.


    |string_unicode|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#string_unicode>

This error is raised when the value cannot be parsed as a Unicode string:

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: str


try:
    Model(x=b'\x81')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'string_unicode'

|


    |time_delta_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#time_delta_parsing>

This error is raised when the input value is a string that cannot be
parsed for a |timedelta| field:

|from datetime import timedelta

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: timedelta


try:
    Model(x='t')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'time_delta_parsing'

|


    |time_delta_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#time_delta_type>

This error is raised when the input value's type is not valid for a |
timedelta| field:

|from datetime import timedelta

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: timedelta


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'time_delta_type'

|

This error is also raised for strict fields when the input value is not
an instance of |timedelta|.


    |time_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#time_parsing>

This error is raised when the input value is a string that cannot be
parsed for a |time| field:

|from datetime import time

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: time


try:
    Model(x='25:20:30.400')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'time_parsing'

|


    |time_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#time_type>

This error is raised when the value type is not valid for a |time| field:

|from datetime import time

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: time


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'time_type'

|

This error is also raised for strict fields when the input value is not
an instance of |time|.


    |timezone_aware|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#timezone_aware>

This error is raised when the |datetime| value provided for a timezone-
aware |datetime| field doesn't have timezone information:

|from datetime import datetime

from pydantic import AwareDatetime, BaseModel, ValidationError


class Model(BaseModel):
    x: AwareDatetime


try:
    Model(x=datetime.now())
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'timezone_aware'

|


    |timezone_naive|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#timezone_naive>

This error is raised when the |datetime| value provided for a timezone-
naive |datetime| field has timezone info:

|from datetime import datetime, timezone

from pydantic import BaseModel, NaiveDatetime, ValidationError


class Model(BaseModel):
    x: NaiveDatetime


try:
    Model(x=datetime.now(tz=timezone.utc))
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'timezone_naive'

|


    |too_long|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#too_long>

This error is raised when the input value's length is greater than the
field's |max_length| constraint:

Python 3.8 and above <#__tabbed_9_1>

Python 3.9 and above <#__tabbed_9_2>

|from typing import List

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: List[int] = Field(max_length=3)


try:
    Model(x=[1, 2, 3, 4])
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'too_long'

|

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: list[int] = Field(max_length=3)


try:
    Model(x=[1, 2, 3, 4])
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'too_long'

|


    |too_short|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#too_short>

This error is raised when the value length is less than the field's |
min_length| constraint:

Python 3.8 and above <#__tabbed_10_1>

Python 3.9 and above <#__tabbed_10_2>

|from typing import List

from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: List[int] = Field(min_length=3)


try:
    Model(x=[1, 2])
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'too_short'

|

|from pydantic import BaseModel, Field, ValidationError


class Model(BaseModel):
    x: list[int] = Field(min_length=3)


try:
    Model(x=[1, 2])
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'too_short'

|


    |tuple_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#tuple_type>

This error is raised when the input value's type is not valid for a |
tuple| field:

Python 3.8 and above <#__tabbed_11_1>

Python 3.9 and above <#__tabbed_11_2>

|from typing import Tuple

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: Tuple[int]


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'tuple_type'

|

|from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    x: tuple[int]


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'tuple_type'

|

This error is also raised for strict fields when the input value is not
an instance of |tuple|.


    |unexpected_keyword_argument|Â¶ <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#unexpected_keyword_argument>

This error is raised when you provide a value by keyword for a
positional-only argument while calling a function decorated with |
validate_call|:

|from pydantic import ValidationError, validate_call


@validate_call
def foo(a: int, /):
    return a


try:
    foo(a=2)
except ValidationError as exc:
    print(repr(exc.errors()[1]['type']))
    #> 'unexpected_keyword_argument'

|

It is also raised when using pydantic.dataclasses and |extra=forbid|:

|from pydantic import TypeAdapter, ValidationError
from pydantic.dataclasses import dataclass


@dataclass(config={'extra': 'forbid'})
class Foo:
    bar: int


try:
    TypeAdapter(Foo).validate_python({'bar': 1, 'foobar': 2})
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'unexpected_keyword_argument'

|


    |unexpected_positional_argument|Â¶ <https://docs.pydantic.dev/2.10/
    errors/validation_errors/#unexpected_positional_argument>

This error is raised when you provide a positional value for a keyword-
only argument while calling a function decorated with |validate_call|:

|from pydantic import ValidationError, validate_call


@validate_call
def foo(*, a: int):
    return a


try:
    foo(2)
except ValidationError as exc:
    print(repr(exc.errors()[1]['type']))
    #> 'unexpected_positional_argument'

|


    |union_tag_invalid|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#union_tag_invalid>

This error is raised when the input's discriminator is not one of the
expected values:

Python 3.8 and above <#__tabbed_12_1>

Python 3.10 and above <#__tabbed_12_2>

|from typing import Literal, Union

from pydantic import BaseModel, Field, ValidationError


class BlackCat(BaseModel):
    pet_type: Literal['blackcat']


class WhiteCat(BaseModel):
    pet_type: Literal['whitecat']


class Model(BaseModel):
    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')


try:
    Model(cat={'pet_type': 'dog'})
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'union_tag_invalid'

|

|from typing import Literal

from pydantic import BaseModel, Field, ValidationError


class BlackCat(BaseModel):
    pet_type: Literal['blackcat']


class WhiteCat(BaseModel):
    pet_type: Literal['whitecat']


class Model(BaseModel):
    cat: BlackCat | WhiteCat = Field(discriminator='pet_type')


try:
    Model(cat={'pet_type': 'dog'})
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'union_tag_invalid'

|


    |union_tag_not_found|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#union_tag_not_found>

This error is raised when it is not possible to extract a discriminator
value from the input:

Python 3.8 and above <#__tabbed_13_1>

Python 3.10 and above <#__tabbed_13_2>

|from typing import Literal, Union

from pydantic import BaseModel, Field, ValidationError


class BlackCat(BaseModel):
    pet_type: Literal['blackcat']


class WhiteCat(BaseModel):
    pet_type: Literal['whitecat']


class Model(BaseModel):
    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')


try:
    Model(cat={'name': 'blackcat'})
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'union_tag_not_found'

|

|from typing import Literal

from pydantic import BaseModel, Field, ValidationError


class BlackCat(BaseModel):
    pet_type: Literal['blackcat']


class WhiteCat(BaseModel):
    pet_type: Literal['whitecat']


class Model(BaseModel):
    cat: BlackCat | WhiteCat = Field(discriminator='pet_type')


try:
    Model(cat={'name': 'blackcat'})
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'union_tag_not_found'

|


    |url_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_parsing>

This error is raised when the input value cannot be parsed as a URL:

|from pydantic import AnyUrl, BaseModel, ValidationError


class Model(BaseModel):
    x: AnyUrl


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'url_parsing'

|


    |url_scheme|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_scheme>

This error is raised when the URL scheme is not valid for the URL type
of the field:

|from pydantic import BaseModel, HttpUrl, ValidationError


class Model(BaseModel):
    x: HttpUrl


try:
    Model(x='ftp://example.com')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'url_scheme'

|


    |url_syntax_violation|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_syntax_violation>

This error is raised when the URL syntax is not valid:

|from pydantic import BaseModel, Field, HttpUrl, ValidationError


class Model(BaseModel):
    x: HttpUrl = Field(strict=True)


try:
    Model(x='http:////example.com')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'url_syntax_violation'

|


    |url_too_long|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_too_long>

This error is raised when the URL length is greater than 2083:

|from pydantic import BaseModel, HttpUrl, ValidationError


class Model(BaseModel):
    x: HttpUrl


try:
    Model(x='x' * 2084)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'url_too_long'

|


    |url_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#url_type>

This error is raised when the input value's type is not valid for a URL
field:

|from pydantic import BaseModel, HttpUrl, ValidationError


class Model(BaseModel):
    x: HttpUrl


try:
    Model(x=None)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'url_type'

|


    |uuid_parsing|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#uuid_parsing>

This error is raised when the input value's type is not valid for a UUID
field:

|from uuid import UUID

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    u: UUID


try:
    Model(u='12345678-124-1234-1234-567812345678')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'uuid_parsing'

|


    |uuid_type|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#uuid_type>

This error is raised when the input value's type is not valid instance
for a UUID field (str, bytes or UUID):

|from uuid import UUID

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    u: UUID


try:
    Model(u=1234567812412341234567812345678)
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'uuid_type'

|


    |uuid_version|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#uuid_version>

This error is raised when the input value's type is not match UUID version:

|from pydantic import UUID5, BaseModel, ValidationError


class Model(BaseModel):
    u: UUID5


try:
    Model(u='a6cc5730-2261-11ee-9c43-2eb5a363657c')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'uuid_version'

|


    |value_error|Â¶ <https://docs.pydantic.dev/2.10/errors/
    validation_errors/#value_error>

This error is raised when a |ValueError| is raised during validation:

|from pydantic import BaseModel, ValidationError, field_validator


class Model(BaseModel):
    x: str

    @field_validator('x')
    @classmethod
    def repeat_b(cls, v):
        raise ValueError()


try:
    Model(x='test')
except ValidationError as exc:
    print(repr(exc.errors()[0]['type']))
    #> 'value_error'

|

Was this page helpful?

Thanks for your feedback!
Thanks for your feedback!

Back to top

Made with Material for MkDocs <https://squidfunk.github.io/mkdocs-
material/>

